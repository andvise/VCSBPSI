#include <QCoreApplication>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <math.h>
#include <stdio.h>
#include <time.h>       /* time */
#include "include/structDef.h"
#include "include/EBM.h"
#include "include/EBM.cpp"
#include <cstring>
#include <iomanip>
#include <limits>
#include "gurobi_c++.h"
#include <fstream>

using namespace std;

#define SMALLITEMMINVOLUME 5
#define SMALLITEMMAXVOLUME 10
#define MEDIUMITEMMINVOLUME 15
#define MEDIUMITEMMAXVOLUME 25
#define LARGEITEMMINVOLUME 20
#define LARGEITEMMAXVOLUME 40

#define SMALLBINVOLUME 50
#define MEDIUMBINVOLUME 70
#define LARGEBINVOLUME 90

#if false
#define ITEMSMIN 50         //size of the problem
#define ITEMSMAX 100
#define LOWERBOUNDEBM 0.7   //lower bound to evaluate the EBM position
#define ALPHAINCREMENT 1.5  //alpha increment of the bins cost
#define MAXLIMITAVERAGE 1   //maximum value of an EBM position for being a valid solution for the second phase
#define SMALLITEMPERC 30     //various percentage of the items
#define MEDIUMITEMPERC 30
#define LARGEBINPERC 40

#else

int ITEMSMIN = 25;        //size of the problem
int ITEMSMAX = 50;
#define LOWERBOUNDEBM 0.7   //lower bound to evaluate the EBM position
float ALPHAINCREMENT = 1;  //alpha increment of the bins cost
float MAXLIMITAVERAGE = 0.7;   //maximum value of an EBM position for being a valid solution for the second phase
#define SMALLITEMPERC 20     //various percentage of the items
#define MEDIUMITEMPERC 20
#define LARGEBINPERC 60

#endif // true


#define USELP false
#define BDFORGUROBI false
#define BDFORGUROBITRAIN true
#define NOLAZYCOMPARE false


float lpBinSolve(std::vector<item> items, std::vector<bin> bins);
std::vector<item> itemsInstanceGenerator(int minNrItems, int maxNrItems, int percSmall, int percMedium, int percBig);
std::vector<bin> binsInstanceGenerator(int totalVolume, int binVolume);
binSet BDF(std::vector<item> items, std::vector<bin> bins);
binSet gurobiSolve(std::vector<item> items, std::vector<bin> bins);
std::vector<bin> binsBookerApplicator(binSet bookedBins, std::vector<bin> smallBins, std::vector<bin> mediumBins, std::vector<bin> largeBins);
void lazyEvaluation(vector< vector < vector <EBM> > > &matrixEBM, vector< vector < vector <int> > > &flag ,int i,int j, int k, int s, int m, int l, int smallBinsNr, int mediumBinsNr, int largeBinsNr);
float costEvaluator(binSet bookedBins, binSet extraBins, std::vector<bin> smallBins, std::vector<bin> mediumBins, std::vector<bin> largeBins);



struct binCompCheap {
    bool operator() (const bin& i,const bin& j) const {
        return (i.cost < j.cost);
    }
} cheapComp;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    vector< vector < vector <EBM> > > matrixEBM;
    vector<bin> smallBins;
    vector<bin> mediumBins;
    vector<bin> largeBins;
    vector<item> items;
    srand(time(NULL));
    int volumeForAverage = 0;
    for(int a = 0; a < 100; a++)
    {
        items = itemsInstanceGenerator(ITEMSMIN,ITEMSMAX,SMALLITEMPERC,MEDIUMITEMPERC,LARGEBINPERC);
        int b = 0;
        for (int b = 0; b < items.size(); b++)
            volumeForAverage+=items.at(b).weight;
    }
    volumeForAverage= volumeForAverage/100;
    smallBins = binsInstanceGenerator(volumeForAverage, SMALLBINVOLUME);
    mediumBins = binsInstanceGenerator(volumeForAverage, MEDIUMBINVOLUME);
    largeBins = binsInstanceGenerator(volumeForAverage, LARGEBINVOLUME);
    int smallBinsNr = smallBins.size();
    int mediumBinsNr = mediumBins.size();
    int largeBinsNr = largeBins.size();
    float binCost[smallBinsNr+1][mediumBinsNr+1][largeBinsNr+1];
    vector< vector< vector <int> > > flag;
    int i,j,k;
    binSet averageTotalExtra;
    binSet EMBTotalExtra;
    float EBMcost = 0, averageCost = 0, totEBM = 0, totAverage = 0;
    matrixEBM.resize(smallBinsNr+1);
    for (i = 0; i < smallBinsNr+1; ++i) {
        matrixEBM[i].resize(mediumBinsNr+1);
        for (j = 0; j < mediumBinsNr+1; ++j)
            matrixEBM[i][j].resize(largeBinsNr+1);
    }
#if NOLAZYCOMPARE
    vector< vector < vector <EBM> > > matrixEBMnoLazy;
    matrixEBMnoLazy.resize(smallBinsNr+1);
    for (int i = 0; i < smallBinsNr+1; ++i) {
        matrixEBMnoLazy[i].resize(mediumBinsNr+1);
        for (int j = 0; j < mediumBinsNr+1; ++j)
            matrixEBMnoLazy[i][j].resize(largeBinsNr+1);
    }
#endif // NOLAZYCOMPARE
    cout<<"dimensioni matrice "<< smallBinsNr+1 <<" "<<mediumBinsNr+1<< " " << largeBinsNr+1 <<"\n";
    int countLazy = 0, countNolazy = 0;
    //**************************************TRANING*******************************************************//
    for(int a = 0; a < 100; a++)
    {
        cout<< "\n "<< a <<"\n";
        smallBins = binsInstanceGenerator(volumeForAverage, SMALLBINVOLUME);
        mediumBins = binsInstanceGenerator(volumeForAverage, MEDIUMBINVOLUME);
        largeBins = binsInstanceGenerator(volumeForAverage, LARGEBINVOLUME);
        sort(mediumBins.begin(),mediumBins.end(),cheapComp);
        sort(largeBins.begin(),largeBins.end(),cheapComp);
        items = itemsInstanceGenerator(ITEMSMIN,ITEMSMAX,SMALLITEMPERC,MEDIUMITEMPERC,LARGEBINPERC);
        sort(items.begin(),items.end());
        //TRAINING MATRIX
        if ( a == 0 )
        {
            flag.resize(smallBinsNr+1);
            for (i = 0; i < smallBinsNr+1; ++i)
            {
                flag[i].resize(mediumBinsNr+1);
                for (j = 0; j < mediumBinsNr+1; ++j)
                    flag[i][j].resize(largeBinsNr+1);
            }
        }
        for ( i = 0; i < smallBinsNr +1 ; i++)
        {
            for (j = 0; j < mediumBinsNr +1; j++)
            {
                for ( k = 0; k < largeBinsNr +1 ; k++)
                {
                    flag[i][j][k] = 0;
                }
            }
        }
        binSet provv;
        //cout<<"\nStart trainig";
        for ( i = 0; i < smallBinsNr +1 ; i++)
        {
            for (j = 0; j < mediumBinsNr +1; j++)
            {
                for ( k = 0; k < largeBinsNr +1 ; k++)
                {
                    if ( (flag[i][j][k] != 1) && ( i*SMALLBINVOLUME + j*MEDIUMBINVOLUME + k*LARGEBINVOLUME > LOWERBOUNDEBM * volumeForAverage) )
                    {
                        countLazy++;
                        provv.small = i;
                        provv.medium = j;
                        provv.large = k;
#if BDFORGUROBITRAIN
                        provv = BDF(items,binsBookerApplicator(provv,smallBins,mediumBins,largeBins));
#else
                        provv = gurobiSolve(items,binsBookerApplicator(provv,smallBins,mediumBins,largeBins));
#endif // BDFORGUROBI
                        //cout<<"\nApplicato per la " << countLazy <<" volta il BDF alla posizione ("<< i << " , " << j << " , " << k << ")  con i seguenti bin extra  ("<< provv.small << " , " << provv.medium << " , " << provv.large << ")";
                        lazyEvaluation(matrixEBM,flag,i,j,k,provv.small,provv.medium,provv.large, smallBinsNr, mediumBinsNr, largeBinsNr);
                    }
                    countNolazy++;
#if NOLAZYCOMPARE
                    provv.small = i;
                    provv.medium = j;
                    provv.large = k;
                    countNolazy++;
                    provv = BDF(items,binsBookerApplicator(provv,smallBins,mediumBins,largeBins));
                    matrixEBMnoLazy[i][j][k].addScenario(provv);
#endif // NOLAZYCOMPARE
                }
            }
        }
    }
    cout<<"\nNo Lazy Call "<< countNolazy <<"\t"<<"Lazy Call  "<< countLazy<< "\nAverage Volume " <<volumeForAverage <<"\n";
    ofstream inputWriter;
    inputWriter.open("EBM.txt");
    int differenceMatrix = 0;
    for ( i = 0; i < smallBinsNr +1 ; i++)
    {
        for (j = 0; j < mediumBinsNr +1; j++)
        {
            for ( k = 0; k < largeBinsNr +1 ; k++)
            {
                inputWriter << "("<< std::fixed << std::setw( 3 )  << std::setprecision(3)  << std::setfill( '0' )  << matrixEBM[i][j][k].getSmallPerc() <<";" << matrixEBM[i][j][k].getMediumPerc() <<";" << matrixEBM[i][j][k].getLargePerc() <<")\t";
            }
            inputWriter << "\t\t";
#if NOLAZYCOMPARE
            for ( k = 0; k < largeBinsNr +1 ; k++)
            {
                inputWriter << "(" << matrixEBMnoLazy[i][j][k].getSmallPerc()<<";"<< matrixEBMnoLazy[i][j][k].getMediumPerc() <<";"<< matrixEBMnoLazy[i][j][k].getLargePerc() <<")\t";
                if ( (matrixEBM[i][j][k].getSmallPerc() != matrixEBMnoLazy[i][j][k].getSmallPerc()) || (matrixEBM[i][j][k].getMediumPerc() != matrixEBMnoLazy[i][j][k].getMediumPerc()) || (matrixEBM[i][j][k].getLargePerc() != matrixEBMnoLazy[i][j][k].getLargePerc()) )
                {
                    differenceMatrix++;
                    // inputWriter << "\n Differenza nella posizione (" << i << "," << j << "," << k << ")\n";
                }
            }
#endif // NOLAZYCOMPARE
            inputWriter << "\n";
        }
        inputWriter << "\n\n";
    }
    int temp = 0;
    for (int i = items.size() - 1; i > 0 ; i--)
        temp+= items.at(i).weight;
    inputWriter << "\nTotal volume "<<temp;
#if NOLAZYCOMPARE
    inputWriter << "\nDifferenze nella matrice" << differenceMatrix;
    inputWriter<<"\nNo Lazy Call "<< countNolazy <<"\t"<<"Lazy Call  "<< countLazy;
#endif
    inputWriter.close();
    //**************************************FINISH OF THE TRANING*******************************************************//
    //**************************************OPERATIVE PHASE*************************************************************//
    inputWriter.open("Difference.txt");
    for (MAXLIMITAVERAGE ; MAXLIMITAVERAGE < 1.5 ; MAXLIMITAVERAGE += 0.2)
    {
        for (ALPHAINCREMENT= 1 ; ALPHAINCREMENT < 2.1 ; ALPHAINCREMENT += 0.2)
            for(float b = 0; b < 0.5  ; b+=0.05)
            {
                for(int a = 0; a < 1  ; a++)
                {
                    cout<<"\nTest nr:" <<a+1<<"\n";
                    //----------------------BIN INSTANCE GENERATION-------------------------------------//
                    smallBins = binsInstanceGenerator(volumeForAverage, SMALLBINVOLUME);
                    mediumBins = binsInstanceGenerator(volumeForAverage, MEDIUMBINVOLUME);
                    largeBins = binsInstanceGenerator(volumeForAverage, LARGEBINVOLUME);
                    sort(smallBins.begin(),smallBins.end(),cheapComp);
                    sort(mediumBins.begin(),mediumBins.end(),cheapComp);
                    sort(largeBins.begin(),largeBins.end(),cheapComp);
                    //----------------------Calculating dynamic cost matrix for the set of bins-------------------------------------//
                    memset(binCost,0,sizeof(binCost));
                    int i, j, k;
                    binCost[0][0][0]= 0;
                    for (j = 1; j < mediumBinsNr +1; j++)
                    {
                        binCost[0][j][0] = binCost[0][j-1][0] + mediumBins.at(j-1).cost;
                    }
                    for ( k = 1; k < largeBinsNr +1 ; k++)
                    {
                        binCost[0][0][k] = binCost[0][0][k-1] + largeBins.at(k-1).cost;
                        for (j = 1; j < mediumBinsNr +1; j++)
                        {
                            binCost[0][j][k] = binCost[0][j-1][k] + mediumBins.at(j-1).cost;
                        }
                    }
                    for ( i = 1; i < smallBinsNr +1 ; i++)
                    {
                        binCost[i][0][0] = binCost[i - 1][0][0] + smallBins.at(i-1).cost;
                        for (j = 0  ; j < mediumBinsNr +1; j++)
                        {
                            if (j!=0)
                                binCost[i][j][0] = binCost[i][j-1][0] + mediumBins.at(j-1).cost;
                            for ( k = 1; k < largeBinsNr +1 ; k++)
                            {
                                binCost[i][j][k] = binCost[i][j][k-1] + largeBins.at(k-1).cost;
                            }
                        }
                    }
                    float minTotalCost = std::numeric_limits<float>::max();
                    binSet EBMMinimumCostSet, averageBookingSet;
                    for ( i = 0; i < smallBinsNr + 1 ; i++)
                    {
                        for (j = 0  ; j < mediumBinsNr + 1; j++)
                        {
                            for ( k = 0; k < largeBinsNr + 1; k++)
                            {
                                if (    ( i*SMALLBINVOLUME + j*MEDIUMBINVOLUME + k*LARGEBINVOLUME > LOWERBOUNDEBM * volumeForAverage) &&
                                        (matrixEBM[i][j][k].getSmallPerc() < MAXLIMITAVERAGE) &&
                                        (matrixEBM[i][j][k].getMediumPerc() < MAXLIMITAVERAGE) &&
                                        (matrixEBM[i][j][k].getLargePerc() < MAXLIMITAVERAGE) &&
                                        (matrixEBM[i][j][k].getSmallPerc() + matrixEBM[i][j][k].getMediumPerc() + matrixEBM[i][j][k].getLargePerc() < 1.7) )
                                {
                                    //cout << i << " , " << j << " , " << k << " .. " << smallBins.size() <<"\n";
                                    /*inputWriter << "(" << i << " , " << j << " , " << k << ")  EBM Matrix ("
                                            << matrixEBM[i][j][k].getSmallPerc() << " , " << matrixEBM[i][j][k].getMediumPerc() << " , " << matrixEBM[i][j][k].getLargePerc()  << ") prec bin Cost"
                                            << binCost[i][j][k]  <<"\nNext bin cost: s=" << ((i < smallBinsNr)  ? (matrixEBM[i][j][k].getSmallPerc() * smallBins.at(i).cost)    : 0 ) <<
                                                                                    "m=" << ((j < mediumBinsNr) ? (matrixEBM[i][j][k].getMediumPerc() * mediumBins.at(j).cost)  : 0 ) <<
                                                                                    "l=" << ((k < largeBinsNr)  ? (matrixEBM[i][j][k].getLargePerc() * largeBins.at(k).cost)    : 0 ) <<"\n";
                                                                                    */
                                    binCost[i][j][k] = binCost[i][j][k] +
                                                       ALPHAINCREMENT * (
                                                           ((i < smallBinsNr)  ? (matrixEBM[i][j][k].getSmallPerc() * smallBins.at(i).cost)    : 0 ) +
                                                           ((j < mediumBinsNr) ? (matrixEBM[i][j][k].getMediumPerc() * mediumBins.at(j).cost)  : 0 ) +
                                                           ((k < largeBinsNr)  ? (matrixEBM[i][j][k].getLargePerc() * largeBins.at(k).cost)    : 0 ));
                                    if (binCost[i][j][k] < minTotalCost)
                                    {
                                        // inputWriter << "New minimum cost: " << binCost[i][j][k] <<"\n";
                                        EBMMinimumCostSet.small    = i;
                                        EBMMinimumCostSet.medium   = j;
                                        EBMMinimumCostSet.large    = k;
                                        minTotalCost = binCost[i][j][k];
                                    }
                                }
                            }
                        }
                    }
                    cout << " The best solution for the algorithms is : (" << EBMMinimumCostSet.small << "," << EBMMinimumCostSet.medium << "," << EBMMinimumCostSet.large <<")\n"
                         <<"With this expected extra bins: (" << matrixEBM[EBMMinimumCostSet.small][EBMMinimumCostSet.medium][EBMMinimumCostSet.large].getSmallPerc() <<","
                         << matrixEBM[EBMMinimumCostSet.small][EBMMinimumCostSet.medium][EBMMinimumCostSet.large].getMediumPerc() <<","
                         << matrixEBM[EBMMinimumCostSet.small][EBMMinimumCostSet.medium][EBMMinimumCostSet.large].getLargePerc() <<")\n";
                    i = 0;
                    j = 0;
                    k = 0;
                    int bookedVolume = 0;
                    averageBookingSet.small    = 0;
                    averageBookingSet.medium   = 0;
                    averageBookingSet.large    = 0;
                    do {
                        if(averageBookingSet.small < smallBins.size())
                        {
                            if ((averageBookingSet.medium < mediumBins.size()) &&
                                    (smallBins.at(averageBookingSet.small).volume * 1.0 / smallBins.at(averageBookingSet.small).cost > mediumBins.at(averageBookingSet.medium).volume * 1.0 / mediumBins.at(averageBookingSet.medium).cost))
                            {
                                if ((averageBookingSet.large < largeBins.size()) &&
                                        (smallBins.at(averageBookingSet.small).volume * 1.0 / smallBins.at(averageBookingSet.small).cost > largeBins.at(averageBookingSet.large).volume * 1.0 / largeBins.at(averageBookingSet.large).cost))
                                {
                                    bookedVolume += smallBins.at(averageBookingSet.small).volume;
                                    averageBookingSet.small++;
                                } else {
                                    bookedVolume += largeBins.at(averageBookingSet.large).volume;
                                    averageBookingSet.large++;
                                }
                            } else
                            {
                                if ((averageBookingSet.large < largeBins.size()) &&
                                        (mediumBins.at(averageBookingSet.medium).volume * 1.0 / mediumBins.at(averageBookingSet.medium).cost > largeBins.at(averageBookingSet.large).volume * 1.0 / largeBins.at(averageBookingSet.large).cost))
                                {
                                    bookedVolume += mediumBins.at(averageBookingSet.medium).volume;
                                    averageBookingSet.medium++;
                                } else {
                                    bookedVolume += largeBins.at(averageBookingSet.large).volume;
                                    averageBookingSet.large++;
                                }
                            }
                        } else
                        {
                            if ((averageBookingSet.medium < mediumBins.size()) &&
                                    (mediumBins.at(averageBookingSet.medium).volume * 1.0 / mediumBins.at(averageBookingSet.medium).cost > largeBins.at(averageBookingSet.large).volume * 1.0 / largeBins.at(averageBookingSet.large).cost))
                            {
                                bookedVolume += mediumBins.at(averageBookingSet.medium).volume;
                                averageBookingSet.medium++;
                            } else {
                                bookedVolume += largeBins.at(averageBookingSet.large).volume;
                                averageBookingSet.large++;
                            }
                        }
                    } while (bookedVolume <= (0.8 + b) * volumeForAverage);
                    cout << " The best solution for the average is : (" << averageBookingSet.small << "," << averageBookingSet.medium << "," << averageBookingSet.large <<")\n";
                    items = itemsInstanceGenerator(ITEMSMIN,ITEMSMAX,SMALLITEMPERC,MEDIUMITEMPERC,LARGEBINPERC);
                    sort(items.begin(),items.end());
#if BDFORGUROBI
                    binSet EBMOperativeExtraBins = BDF(items,binsBookerApplicator(EBMMinimumCostSet,smallBins,mediumBins,largeBins));
                    binSet averageOperativeExtraBins = BDF(items,binsBookerApplicator(averageBookingSet,smallBins,mediumBins,largeBins));
#else
                    binSet EBMOperativeExtraBins = gurobiSolve(items,binsBookerApplicator(EBMMinimumCostSet,smallBins,mediumBins,largeBins));
                    binSet averageOperativeExtraBins = gurobiSolve(items,binsBookerApplicator(averageBookingSet,smallBins,mediumBins,largeBins));
#endif // BDFORGUROBI
                    EMBTotalExtra.small += EBMOperativeExtraBins.small;
                    EMBTotalExtra.medium += EBMOperativeExtraBins.medium;
                    EMBTotalExtra.large += EBMOperativeExtraBins.large;
                    averageTotalExtra.small += averageOperativeExtraBins.small;
                    averageTotalExtra.medium += averageOperativeExtraBins.medium;
                    averageTotalExtra.large += averageOperativeExtraBins.large;
                    float EBMcost = 0, averageCost = 0;
                    EBMcost     = costEvaluator(EBMMinimumCostSet, EBMOperativeExtraBins,smallBins,mediumBins,largeBins);
                    //    cout << "Extra bins for EBM: (" << EBMOperativeExtraBins.small << "," << EBMOperativeExtraBins.medium << "," << EBMOperativeExtraBins.large <<")\n";
                    averageCost = costEvaluator(averageBookingSet, averageOperativeExtraBins,smallBins,mediumBins,largeBins);
                    //    cout << "Extra bins for average: (" << averageOperativeExtraBins.small << "," << averageOperativeExtraBins.medium << "," << averageOperativeExtraBins.large <<")\n";
                    totEBM+=EBMcost;
                    totAverage+=averageCost;
                    // cout << "EBM = " << std::fixed << std::setw( 5 )  << std::setprecision(3)  << std::setfill( '0' )  << EBMcost <<"\t\taverage = " << averageCost<<"\n\n" ;
                    cout << "TOTAL EBM = " << std::fixed << std::setw( 5 )  << std::setprecision(3)  << std::setfill( '0' )  << totEBM <<"\t\taverage = " << totAverage<<"\n\n\n" ;
                    cout << "EBM EXTRA BINS = (" << EMBTotalExtra.small << "," << EMBTotalExtra.medium << "," << EMBTotalExtra.large << ")\t "
                         << "average = (" << averageTotalExtra.small << "," << averageTotalExtra.medium << "," << averageTotalExtra.large << "\n\n" ;
                }
                inputWriter     << std::fixed << std::setw( 5 )  << std::setprecision(3)  << std::setfill( '0' )
                                << ALPHAINCREMENT <<"\t" << MAXLIMITAVERAGE <<"\t" << (0.8 + b) <<"\t" << totEBM <<"\t" << totAverage << "\n";/*
                        << EMBTotalExtra.small << "\t" << EMBTotalExtra.medium << "\t" << EMBTotalExtra.large << "\t"
                        << averageTotalExtra.small << "\t" << averageTotalExtra.medium << "\t" << averageTotalExtra.large << "\n" ;*/
                EMBTotalExtra.small = 0;
                EMBTotalExtra.medium = 0;
                EMBTotalExtra.large = 0;
                averageTotalExtra.small = 0;
                averageTotalExtra.medium = 0;
                averageTotalExtra.large = 0;
                totEBM=0;
                totAverage=0;
            }
    }
    /*#if USELP
            temp = lpBinSolve(items,freeBins);
            cout <<"lp solve: "<< temp<< "\t\t";
            totalLp += temp;
        instream.close();

            temp = BFD(items,freeBins);
            cout <<"BDF: "<< temp<< "\n";
            totalBDF+=temp;
    #endif
    */
    inputWriter.close();
    inputWriter.close();
    return a.exec();
}

float costEvaluator(binSet bookedBins, binSet extraBins, std::vector<bin> smallBins, std::vector<bin> mediumBins, std::vector<bin> largeBins)
{
    int i;
    float cost = 0;
    for ( i = 0; i < bookedBins.small; i++)
        cost += smallBins.at(i).cost;
    for ( i = 0; i < bookedBins.medium; i++)
        cost += mediumBins.at(i).cost;
    for ( i = 0; i < bookedBins.large; i++)
        cost += largeBins.at(i).cost;
    for ( i = bookedBins.small; i < bookedBins.small + extraBins.small; i++)
        cost += ALPHAINCREMENT * smallBins.at(i).cost;
    for ( i = bookedBins.medium; i < bookedBins.medium + extraBins.medium; i++)
        cost += ALPHAINCREMENT * mediumBins.at(i).cost;
    for ( i = bookedBins.large; i < bookedBins.large + extraBins.large; i++)
        cost += ALPHAINCREMENT * largeBins.at(i).cost;
    return cost;
}



void lazyEvaluation(vector< vector < vector <EBM> > > &matrixEBM, vector< vector < vector <int> > > & flag,int i,int j, int k, int s, int m, int l, int smallBinsNr, int mediumBinsNr, int largeBinsNr)
{
    binSet provv;
    if ((i <= smallBinsNr) && (j <= mediumBinsNr) && (k <= largeBinsNr) && (flag[i][j][k] != 1))
    {
        provv.small = s;
        provv.medium = m;
        provv.large = l;
        //cout<<"calling add scenario : position ("<< i <<"," << j << "," << k <<") provv = (" << s << "," << m << "," << l << ")\n";
        matrixEBM[i][j][k].addScenario(provv);
        flag[i][j][k] = 1;
#if true //lazy evaluation extender
        if (s > 0)
            lazyEvaluation(matrixEBM , flag, i+1 , j , k , s-1 , m , l, smallBinsNr, mediumBinsNr, largeBinsNr);
        if (m > 0)
            lazyEvaluation(matrixEBM , flag, i , j+1 , k , s , m-1 , l, smallBinsNr, mediumBinsNr, largeBinsNr);
        if (l > 0)
            lazyEvaluation(matrixEBM , flag, i , j , k + 1 , s , m , l -1, smallBinsNr, mediumBinsNr, largeBinsNr);
#endif
        if (( s == 0 ) && ( m == 0 ) && ( l == 0 ))
        {
            lazyEvaluation(matrixEBM , flag, i+1 , j , k , 0,0,0, smallBinsNr, mediumBinsNr, largeBinsNr);
            lazyEvaluation(matrixEBM , flag, i , j+1 , k , 0,0,0, smallBinsNr, mediumBinsNr, largeBinsNr);
            lazyEvaluation(matrixEBM , flag, i , j , k+1 , 0,0,0, smallBinsNr, mediumBinsNr, largeBinsNr);
        }
    }
}

//generate an set of items to pack
vector<item> itemsInstanceGenerator(int minNrItems, int maxNrItems, int percSmall, int percMedium, int percBig)
{
    vector<item> instance;
    item temp;
    if (percSmall + percMedium + percBig != 100)
    {
        cout << "Error, mistake in percantage on instance generator";
        return instance;
    }
    int itemsNr = minNrItems + rand()%(maxNrItems - minNrItems) + 1;
    //cout << rand() <<"   itemnumber " << itemsNr <<" \n";
    for (int i = 0; i < itemsNr * percSmall / 100.0; i++)
    {
        temp.code=1000+i;
        temp.weight = SMALLITEMMINVOLUME + rand()%(SMALLITEMMAXVOLUME - SMALLITEMMINVOLUME);
        instance.push_back(temp);
    }
    for (int i = 0; i < itemsNr * percMedium / 100.0; i++)
    {
        temp.code=2000+i;
        temp.weight = MEDIUMITEMMINVOLUME + rand()%(MEDIUMITEMMAXVOLUME - MEDIUMITEMMINVOLUME);
        instance.push_back(temp);
    }
    for (int i = 0; i < itemsNr * percBig / 100.0; i++)
    {
        temp.code=3000+i;
        temp.weight = LARGEITEMMINVOLUME + rand()%(LARGEITEMMAXVOLUME - LARGEITEMMINVOLUME);
        instance.push_back(temp);
    }
    return instance;
}

//generate an set of bins
vector<bin> binsInstanceGenerator(int totalVolume, int binVolume)
{
    vector<bin> instance;
    bin temp;
    totalVolume*=1.4;
    temp.volume = binVolume;
    temp.volumeRemaining = binVolume;
    for (int i = 0; i < totalVolume / binVolume; i++)
    {
        temp.cost = (sqrt(binVolume) * (1.0 + ( (rand() % 60 - 30.0)/100)));
        temp.code = binVolume*10+i;
        instance.push_back(temp);
    }
    return instance;
}
//prepare a single instance considering 0 the cost of all the bins booked in the first phase
std::vector<bin> binsBookerApplicator(binSet bookedBins, std::vector<bin> smallBins, std::vector<bin> mediumBins, std::vector<bin> largeBins)
{
    vector<bin> instance;
    for (int i = 0; i < smallBins.size(); i++)
    {
        instance.push_back(smallBins.at(i));
        if (i < bookedBins.small)
            instance.at(instance.size() - 1).cost= 0;
    }
    for (int i = 0; i < mediumBins.size(); i++)
    {
        instance.push_back(mediumBins.at(i));
        if (i < bookedBins.medium)
            instance.at(instance.size() - 1).cost= 0;
    }
    for (int i = 0; i < largeBins.size(); i++)
    {
        instance.push_back(largeBins.at(i));
        if (i < bookedBins.large)
            instance.at(instance.size() - 1).cost= 0;
    }
    sort(instance.begin(),instance.end());
    return instance;
}

struct binComp {
    bool operator() (const bin& i,const bin& j) const {
        return (i.volumeRemaining < j.volumeRemaining);
    }
} upComp;


binSet BDF(vector<item> items, vector<bin> bins) //NB richiede gli item già ordinati
{
    vector<bin> bookedBins;
    binSet extra;
    bookedBins.push_back(bins.at(bins.size()-1));
    bins.pop_back();
    //  cout << "prenotato il  bin " << bookedBins.at(0).code << " con il volume " << bookedBins.at(0).volume << "\n" ;
    for (int i = items.size() - 1; i > 0 ; i--)
    {
        if (!( items.at(i).weight <= bookedBins.at(bookedBins.size()-1).volumeRemaining ))
        {
            bookedBins.push_back(bins.at(bins.size()-1));
            bins.pop_back();
            if(bookedBins.at(bookedBins.size()-1).cost != 0)
                switch (bookedBins.at(bookedBins.size()-1).volume)
                {
                case SMALLBINVOLUME:
                    //cout <<"aumento di 1 i bidoni piccoli "<< extra.small<< "\n" ;
                    extra.small++;
                    break;
                case MEDIUMBINVOLUME:
                    //cout <<"aumento di 1 i bidoni medi "<< extra.medium<< "\n" ;
                    extra.medium++;
                    break;
                case LARGEBINVOLUME:
                    extra.large++;
                    //cout <<"aumento di 1 i bidoni larghi "<< extra.large<< "\n" ;
                    break;
                }
            //cout <<"prenotato il  bin " << bookedBins.at(bookedBins.size()-1).code << " con il volume " << bookedBins.at(bookedBins.size()-1).volume  << "\n" ;
        }
        bookedBins.at(bookedBins.size()-1).volumeRemaining -= items.at(i).weight;
        //cout <<"item "<< items.at(i).code << " nel bin " << bookedBins.at(bookedBins.size()-1).code << " con il volume rimanente "<< bookedBins.at(bookedBins.size()-1).volumeRemaining<< "\n" ;
        sort(bookedBins.begin(),bookedBins.end(),upComp);
    }
    // cout<<"Il valore dell'bdf è  "<< extra.small<< ","<< extra.medium<< " "<< extra.large<< "\n";
    return extra;
}


binSet gurobiSolve(vector<item> items, vector<bin> bins)
{
    cout<<"entro in gurobi\n";
    GRBEnv env = GRBEnv();
    GRBModel model = GRBModel(env);
    const int binSize = bins.size();
    const int itemSize = items.size();
    GRBVar binsVar[binSize];
    GRBVar itemVars[binSize][itemSize];
    int i, j;
    // Create the bin selected variables
    for (i = 0; i < binSize ; i++)
        binsVar[i] = model.addVar(0.0, 1.0, bins.at(i).cost, GRB_BINARY);
    // Create the bin assignment variables
    for (i = 0; i < binSize ; i++)
        for(j = 0; j < itemSize ; j++)
            itemVars[i][j] = model.addVar(0.0, 1.0, 0.0, GRB_BINARY);
    // Integrate variables into model
    model.update();
    // Add constraints
    // Each items has to be packed in a bin
    for(j = 0; j < itemSize ; j++)
    {
        GRBLinExpr expr = 0;
        for (i = 0; i < binSize ; i++)
            expr += itemVars[i][j];
        model.addConstr(expr, GRB_EQUAL, 1.0);
    }
    cout<<"3\n";
    // The volume of the bin cannot be exceeded
    for (i = 0; i < binSize ; i++)
    {
        GRBLinExpr expr = 0;
        for(j = 0; j < itemSize ; j++)
            expr += items.at(j).weight * itemVars[i][j];
        expr -= bins.at(i).volume * binsVar[i];
        model.addConstr(expr <= 0.0);
    }
    cout<<"3\n";
    // Optimize model
    model.optimize();
    binSet output;
    output.small = 0;
    output.medium = 0;
    output.large = 0;
    for (i = 0; i < binSize ; i++)
    {
        if (binsVar[i].get(GRB_DoubleAttr_X) > 0.5)
        {
            switch (bins.at(i).volume) {
            case SMALLBINVOLUME :
                output.small++;
                break;
            case MEDIUMBINVOLUME :
                output.medium++;
                break;
            case LARGEBINVOLUME :
                output.large++;
                break;
            }
        }
    }
    cout<<"esco in gurobi\n\n";
    return output;
}

#if USELP

float lpBinSolve(vector<item> items, vector<bin> bins)
{
    lprec *lp;
    int size = bins.size() + bins.size() * items.size();
    if ((lp = make_lp(0,size)) == NULL)
        cout<<"error in create the lp\n";
    /* Now redirect all output to a file */
    /* set_outputfile(lp, "result.txt"); */
    double row[size];
    //cout<<  bins.size() <<" è il numero di barili \n";
    for (int i = 0; i < bins.size(); i++)
    {
        //cout<< "il barile "<< i << " ha costo "<<bins.at(i).cost<<"\n";
        row[i+1]=bins.at(i).cost;
        set_int(lp, i+1, TRUE);
        set_upbo(lp , i+1 , 1);
    }
    for (int i = bins.size(); i < size; i++)
    {
        row[i+1]=0;
        set_int(lp, i+1, TRUE);
        set_upbo(lp , i+1 ,1);
    }
    set_obj_fn(lp, row);
    for (int b = 0; b < bins.size(); b++)
    {
        memset(row, 0, sizeof(row)+1); // for automatically-allocated arrays
        for (int i = 0; i < items.size(); i++)
        {
            row[bins.size() + b * items.size() + i + 1] = items.at(i).weight;
        }
        row[b+1]= -bins.at(b).volume;
        add_constraint(lp, row , LE, 0);
    }
    for (int i = 0; i < items.size(); i++)
    {
        memset(row, 0, sizeof(row)+ 1); // for automatically-allocated arrays
        row[size]=0;
        for (int b = 0; b < bins.size(); b++)
        {
            row[bins.size() + 1 + items.size() * b + i] = 1;
        }
        add_constraint(lp, row , EQ, 1);
    }
    solve(lp);
    /*

          print_lp(lp);
          print_objective(lp);
          print_solution(lp, 1);
          print_constraints(lp, 1);
    */
    float solution= get_var_primalresult(lp,0);
    delete_lp(lp);
    return solution;
}
#endif

